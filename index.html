<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–°—Ç–∞—Ä–∏–∫–∞–º —Ç—É—Ç –Ω–µ –º–µ—Å—Ç–æ! ‚Äî –û–Ω–ª–∞–π–Ω –®–∞—à–∫–∏</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #0a0a0a;
    color: #e0e0e0;
    font-family: 'Russo One', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Animated background */
  body::before {
    content: '';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: 
      radial-gradient(ellipse at 20% 50%, rgba(255, 60, 0, 0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 20%, rgba(255, 165, 0, 0.06) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 80%, rgba(139, 0, 0, 0.08) 0%, transparent 50%);
    z-index: -1;
    animation: bgPulse 8s ease-in-out infinite alternate;
  }

  @keyframes bgPulse {
    0% { opacity: 0.5; }
    100% { opacity: 1; }
  }

  /* Particles */
  .particles {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: -1;
    overflow: hidden;
  }

  .particle {
    position: absolute;
    width: 2px;
    height: 2px;
    background: rgba(255, 100, 0, 0.6);
    border-radius: 50%;
    animation: float linear infinite;
  }

  @keyframes float {
    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(-10vh) rotate(720deg); opacity: 0; }
  }

  .container {
    max-width: 1000px;
    margin: 0 auto;
    padding: 20px;
  }

  /* Header */
  .header {
    text-align: center;
    padding: 30px 0 20px;
  }

  .header h1 {
    font-family: 'Press Start 2P', cursive;
    font-size: clamp(16px, 4vw, 32px);
    color: #ff4500;
    text-shadow: 0 0 20px rgba(255, 69, 0, 0.5), 0 0 40px rgba(255, 69, 0, 0.3);
    letter-spacing: 2px;
    animation: titleGlow 2s ease-in-out infinite alternate;
    line-height: 1.4;
  }

  @keyframes titleGlow {
    0% { text-shadow: 0 0 20px rgba(255, 69, 0, 0.5), 0 0 40px rgba(255, 69, 0, 0.3); }
    100% { text-shadow: 0 0 30px rgba(255, 69, 0, 0.8), 0 0 60px rgba(255, 69, 0, 0.5), 0 0 80px rgba(255, 69, 0, 0.3); }
  }

  .subtitle {
    font-size: 14px;
    color: #888;
    margin-top: 10px;
    font-style: italic;
  }

  /* Screens */
  .screen {
    display: none;
    animation: fadeIn 0.5s ease;
  }

  .screen.active {
    display: block;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
  }

  /* Menu */
  .menu {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    margin-top: 40px;
  }

  .btn {
    font-family: 'Russo One', sans-serif;
    font-size: 18px;
    padding: 15px 40px;
    border: 2px solid #ff4500;
    background: rgba(255, 69, 0, 0.1);
    color: #ff6633;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 2px;
    position: relative;
    overflow: hidden;
    min-width: 300px;
    text-align: center;
  }

  .btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 69, 0, 0.2), transparent);
    transition: left 0.5s;
  }

  .btn:hover::before {
    left: 100%;
  }

  .btn:hover {
    background: rgba(255, 69, 0, 0.3);
    box-shadow: 0 0 30px rgba(255, 69, 0, 0.4), inset 0 0 30px rgba(255, 69, 0, 0.1);
    transform: scale(1.05);
  }

  .btn:active {
    transform: scale(0.98);
  }

  .btn-small {
    font-size: 14px;
    padding: 10px 25px;
    min-width: 200px;
  }

  .btn-danger {
    border-color: #cc0000;
    color: #ff3333;
    background: rgba(204, 0, 0, 0.1);
  }

  .btn-danger:hover {
    background: rgba(204, 0, 0, 0.3);
    box-shadow: 0 0 30px rgba(204, 0, 0, 0.4);
  }

  .btn-success {
    border-color: #00cc44;
    color: #33ff77;
    background: rgba(0, 204, 68, 0.1);
  }

  .btn-success:hover {
    background: rgba(0, 204, 68, 0.3);
    box-shadow: 0 0 30px rgba(0, 204, 68, 0.4);
  }

  /* Room code */
  .room-section {
    text-align: center;
    margin-top: 30px;
  }

  .room-code-display {
    font-family: 'Press Start 2P', cursive;
    font-size: 36px;
    color: #ff4500;
    letter-spacing: 8px;
    margin: 20px 0;
    padding: 20px;
    border: 2px dashed rgba(255, 69, 0, 0.4);
    background: rgba(255, 69, 0, 0.05);
    user-select: all;
    cursor: pointer;
  }

  .room-code-display:hover {
    border-color: #ff4500;
    background: rgba(255, 69, 0, 0.1);
  }

  .input-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 20px 0;
    flex-wrap: wrap;
  }

  input[type="text"] {
    font-family: 'Press Start 2P', cursive;
    font-size: 20px;
    padding: 15px 20px;
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid #444;
    color: #ff6633;
    text-align: center;
    letter-spacing: 5px;
    width: 250px;
    text-transform: uppercase;
    transition: border-color 0.3s;
  }

  input[type="text"]:focus {
    outline: none;
    border-color: #ff4500;
    box-shadow: 0 0 20px rgba(255, 69, 0, 0.3);
  }

  input[type="text"]::placeholder {
    color: #555;
    font-size: 12px;
    letter-spacing: 2px;
  }

  /* Status */
  .status {
    text-align: center;
    padding: 15px;
    margin: 15px 0;
    font-size: 16px;
    border-left: 3px solid #ff4500;
    background: rgba(255, 69, 0, 0.05);
  }

  .status.waiting {
    border-color: #ffaa00;
    color: #ffaa00;
  }

  .status.connected {
    border-color: #00cc44;
    color: #33ff77;
  }

  .status.error {
    border-color: #cc0000;
    color: #ff3333;
  }

  /* Spinner */
  .spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid rgba(255, 165, 0, 0.3);
    border-top-color: #ffaa00;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    vertical-align: middle;
    margin-right: 10px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Game Board */
  .game-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
  }

  .game-info {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    max-width: 480px;
    gap: 10px;
  }

  .player-info {
    padding: 10px 20px;
    border: 1px solid #333;
    background: rgba(255, 255, 255, 0.03);
    font-size: 14px;
    flex: 1;
    text-align: center;
  }

  .player-info.active-player {
    border-color: #ff4500;
    box-shadow: 0 0 15px rgba(255, 69, 0, 0.3);
    background: rgba(255, 69, 0, 0.1);
  }

  .player-info .color-dot {
    display: inline-block;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
  }

  .player-info .color-dot.white { background: #e8d5b0; border: 1px solid #999; }
  .player-info .color-dot.black { background: #2a1a0a; border: 1px solid #555; }

  .turn-indicator {
    text-align: center;
    font-size: 18px;
    color: #ff4500;
    padding: 10px;
    min-height: 44px;
  }

  .board-container {
    position: relative;
  }

  .board {
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    gap: 0;
    border: 3px solid #8B4513;
    box-shadow: 0 0 30px rgba(139, 69, 19, 0.3), 0 0 60px rgba(0, 0, 0, 0.5);
    width: min(480px, 90vw);
    height: min(480px, 90vw);
  }

  .cell {
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: background 0.2s;
  }

  .cell.light {
    background: #f0d9b5;
  }

  .cell.dark {
    background: #b58863;
  }

  .cell.dark.highlight {
    background: rgba(255, 200, 0, 0.5);
    cursor: pointer;
  }

  .cell.dark.highlight::after {
    content: '';
    position: absolute;
    width: 30%;
    height: 30%;
    background: rgba(255, 200, 0, 0.7);
    border-radius: 50%;
    animation: pulseHighlight 1s ease-in-out infinite;
  }

  .cell.dark.selected {
    background: rgba(255, 69, 0, 0.5);
    box-shadow: inset 0 0 15px rgba(255, 69, 0, 0.5);
  }

  @keyframes pulseHighlight {
    0%, 100% { transform: scale(1); opacity: 0.7; }
    50% { transform: scale(1.2); opacity: 1; }
  }

  .piece {
    width: 75%;
    height: 75%;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    z-index: 2;
  }

  .piece.white-piece {
    background: radial-gradient(circle at 35% 35%, #fff, #e8d5b0, #c4a77d);
    box-shadow: 0 3px 6px rgba(0,0,0,0.4), inset 0 -2px 4px rgba(0,0,0,0.2);
    border: 2px solid #a08060;
  }

  .piece.black-piece {
    background: radial-gradient(circle at 35% 35%, #5a3a1a, #2a1a0a, #1a0a00);
    box-shadow: 0 3px 6px rgba(0,0,0,0.6), inset 0 -2px 4px rgba(0,0,0,0.3);
    border: 2px solid #3a2a1a;
  }

  .piece:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 15px rgba(255, 69, 0, 0.4);
  }

  .piece.king::after {
    content: '‚ôõ';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: clamp(16px, 3vw, 24px);
    color: gold;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
    filter: drop-shadow(0 0 3px rgba(0,0,0,0.8));
  }

  /* Captured pieces */
  .captured {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    min-height: 30px;
  }

  .captured-piece {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    opacity: 0.5;
  }

  .captured-piece.white-piece {
    background: #e8d5b0;
    border: 1px solid #999;
  }

  .captured-piece.black-piece {
    background: #2a1a0a;
    border: 1px solid #555;
  }

  /* Modal */
  .modal-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }

  .modal-overlay.active {
    display: flex;
  }

  .modal {
    background: #1a1a1a;
    border: 2px solid #ff4500;
    padding: 40px;
    text-align: center;
    max-width: 450px;
    width: 90%;
    box-shadow: 0 0 50px rgba(255, 69, 0, 0.3);
    animation: modalIn 0.3s ease;
  }

  @keyframes modalIn {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    font-family: 'Press Start 2P', cursive;
    font-size: 20px;
    color: #ff4500;
    margin-bottom: 15px;
    line-height: 1.5;
  }

  .modal p {
    font-size: 16px;
    color: #aaa;
    margin-bottom: 25px;
  }

  .modal .btn {
    margin: 5px;
  }

  /* Chat */
  .chat-box {
    width: 100%;
    max-width: 480px;
    margin-top: 15px;
    border: 1px solid #333;
    background: rgba(0,0,0,0.3);
  }

  .chat-messages {
    height: 120px;
    overflow-y: auto;
    padding: 10px;
    font-size: 13px;
  }

  .chat-messages .msg {
    margin-bottom: 5px;
    padding: 3px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
  }

  .chat-messages .msg .sender {
    color: #ff6633;
    font-weight: bold;
  }

  .chat-messages .msg.system {
    color: #888;
    font-style: italic;
  }

  .chat-input-row {
    display: flex;
    border-top: 1px solid #333;
  }

  .chat-input-row input {
    flex: 1;
    padding: 10px;
    background: rgba(255,255,255,0.05);
    border: none;
    color: #e0e0e0;
    font-family: 'Russo One', sans-serif;
    font-size: 13px;
  }

  .chat-input-row input:focus { outline: none; }

  .chat-input-row button {
    padding: 10px 15px;
    background: rgba(255, 69, 0, 0.2);
    border: none;
    border-left: 1px solid #333;
    color: #ff4500;
    cursor: pointer;
    font-family: 'Russo One', sans-serif;
    transition: background 0.2s;
  }

  .chat-input-row button:hover {
    background: rgba(255, 69, 0, 0.4);
  }

  /* Lobby */
  .lobby-list {
    max-width: 500px;
    margin: 20px auto;
  }

  .lobby-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 20px;
    border: 1px solid #333;
    margin-bottom: 8px;
    background: rgba(255,255,255,0.02);
    transition: all 0.2s;
  }

  .lobby-item:hover {
    border-color: #ff4500;
    background: rgba(255, 69, 0, 0.05);
  }

  .lobby-item .room-name {
    color: #ff6633;
    font-size: 16px;
  }

  .lobby-item .room-status {
    color: #888;
    font-size: 12px;
  }

  /* Responsive */
  @media (max-width: 500px) {
    .board {
      width: 95vw;
      height: 95vw;
    }
    .btn { min-width: 250px; font-size: 14px; padding: 12px 20px; }
    .room-code-display { font-size: 24px; letter-spacing: 5px; }
    input[type="text"] { font-size: 16px; width: 200px; }
  }

  /* Copy notification */
  .copy-toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255, 69, 0, 0.9);
    color: white;
    padding: 10px 25px;
    font-size: 14px;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }

  .copy-toast.show {
    opacity: 1;
  }

  .rules-section {
    max-width: 500px;
    margin: 20px auto;
    padding: 20px;
    border: 1px solid #333;
    background: rgba(255,255,255,0.02);
    font-size: 14px;
    line-height: 1.8;
    color: #aaa;
  }

  .rules-section h3 {
    color: #ff4500;
    margin-bottom: 10px;
  }

  /* Sound toggle */
  .sound-btn {
    position: fixed;
    top: 15px;
    right: 15px;
    background: rgba(0,0,0,0.5);
    border: 1px solid #444;
    color: #888;
    width: 40px;
    height: 40px;
    cursor: pointer;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
    transition: all 0.2s;
  }

  .sound-btn:hover {
    border-color: #ff4500;
    color: #ff4500;
  }
</style>
</head>
<body>

<div class="particles" id="particles"></div>

<button class="sound-btn" id="soundBtn" title="–ó–≤—É–∫">üîä</button>

<div class="copy-toast" id="copyToast">–ö–æ–¥ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!</div>

<div class="container">
  <div class="header">
    <h1>–°–¢–ê–†–ò–ö–ê–ú –¢–£–¢<br>–ù–ï –ú–ï–°–¢–û!</h1>
    <p class="subtitle">–û–Ω–ª–∞–π–Ω —à–∞—à–∫–∏ ‚Äî –Ω–∞–∫–æ–Ω—á–∞–π –≤ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞!</p>
  </div>

  <!-- MENU SCREEN -->
  <div class="screen active" id="menuScreen">
    <div class="menu">
      <button class="btn" onclick="createRoom()">üî• –°–æ–∑–¥–∞—Ç—å –∫–æ–º–Ω–∞—Ç—É</button>
      <button class="btn" onclick="showJoinScreen()">‚ö° –ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
      <button class="btn btn-small" onclick="showRules()">üìú –ü—Ä–∞–≤–∏–ª–∞</button>
    </div>
  </div>

  <!-- RULES SCREEN -->
  <div class="screen" id="rulesScreen">
    <div class="rules-section">
      <h3>üìú –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã</h3>
      <p>‚Ä¢ –ò–≥—Ä–∞—é—Ç –¥–≤–æ–µ ‚Äî –±–µ–ª—ã–µ –∏ —á—ë—Ä–Ω—ã–µ<br>
      ‚Ä¢ –ë–µ–ª—ã–µ —Ö–æ–¥—è—Ç –ø–µ—Ä–≤—ã–º–∏<br>
      ‚Ä¢ –®–∞—à–∫–∏ —Ö–æ–¥—è—Ç –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –Ω–∞ –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É –≤–ø–µ—Ä—ë–¥<br>
      ‚Ä¢ –ï—Å–ª–∏ –º–æ–∂–Ω–æ –ø–æ–±–∏—Ç—å ‚Äî –±–µ–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ<br>
      ‚Ä¢ –ë–∏—Ç—å –º–æ–∂–Ω–æ –ø–µ—Ä–µ–ø—Ä—ã–≥–∏–≤–∞—è —á–µ—Ä–µ–∑ —à–∞—à–∫—É –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞<br>
      ‚Ä¢ –°–µ—Ä–∏—è –≤–∑—è—Ç–∏–π –∑–∞ –æ–¥–∏–Ω —Ö–æ–¥ (–º—É–ª—å—Ç–∏–∫–∞–ø—á–µ—Ä)<br>
      ‚Ä¢ –®–∞—à–∫–∞, –¥–æ—à–µ–¥—à–∞—è –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä—è–¥–∞, —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –¥–∞–º–∫–æ–π (‚ôõ)<br>
      ‚Ä¢ –î–∞–º–∫–∞ —Ö–æ–¥–∏—Ç –Ω–∞ –æ–¥–Ω—É –∫–ª–µ—Ç–∫—É –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏<br>
      ‚Ä¢ –¢–≤–æ—è –º–∞–º–∫–∞ —É–º—Ä–µ—Ç!<br>
      ‚Ä¢ –ü–æ–±–µ–∂–¥–∞–µ—Ç —Ç–æ—Ç, –∫—Ç–æ –∑–∞–±–µ—Ä—ë—Ç –≤—Å–µ —à–∞—à–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –∏–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä—É–µ—Ç –∏—Ö</p>
    </div>
    <div style="text-align:center; margin-top: 15px;">
      <button class="btn btn-small" onclick="showMenu()">‚Üê –ù–∞–∑–∞–¥</button>
    </div>
  </div>

  <!-- CREATE ROOM SCREEN -->
  <div class="screen" id="createScreen">
    <div class="room-section">
      <h2 style="color:#ff4500; margin-bottom: 10px;">–ö–æ–º–Ω–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞!</h2>
      <p style="color:#888;">–û—Ç–ø—Ä–∞–≤—å —ç—Ç–æ—Ç –∫–æ–¥ –¥—Ä—É–≥—É:</p>
      <div class="room-code-display" id="roomCodeDisplay" onclick="copyRoomCode()" title="–ù–∞–∂–º–∏, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å">---</div>
      <p style="color:#666; font-size:12px;">–ù–∞–∂–º–∏ –Ω–∞ –∫–æ–¥, —á—Ç–æ–±—ã —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</p>
      <div class="status waiting" id="createStatus">
        <span class="spinner"></span> –û–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...
      </div>
      <button class="btn btn-small btn-danger" onclick="cancelRoom()" style="margin-top:15px;">–û—Ç–º–µ–Ω–∞</button>
    </div>
  </div>

  <!-- JOIN ROOM SCREEN -->
  <div class="screen" id="joinScreen">
    <div class="room-section">
      <h2 style="color:#ff4500; margin-bottom: 10px;">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</h2>
      <p style="color:#888;">–í–≤–µ–¥–∏ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã:</p>
      <div class="input-group">
        <input type="text" id="joinCodeInput" placeholder="–ö–û–î" maxlength="6" autocomplete="off" spellcheck="false">
        <button class="btn btn-success btn-small" onclick="joinRoom()">–í–æ–π—Ç–∏</button>
      </div>
      <div class="status" id="joinStatus" style="display:none;"></div>
      <button class="btn btn-small btn-danger" onclick="showMenu()" style="margin-top:15px;">‚Üê –ù–∞–∑–∞–¥</button>
    </div>
  </div>

  <!-- GAME SCREEN -->
  <div class="screen" id="gameScreen">
    <div class="game-wrapper">
      <div class="game-info">
        <div class="player-info" id="player1Info">
          <span class="color-dot white"></span> –ë–µ–ª—ã–µ
        </div>
        <div class="player-info" id="player2Info">
          <span class="color-dot black"></span> –ß—ë—Ä–Ω—ã–µ
        </div>
      </div>

      <div class="captured" id="capturedBlack"></div>

      <div class="turn-indicator" id="turnIndicator">–•–æ–¥ –±–µ–ª—ã—Ö</div>

      <div class="board-container">
        <div class="board" id="board"></div>
      </div>

      <div class="captured" id="capturedWhite"></div>

      <div class="chat-box">
        <div class="chat-messages" id="chatMessages">
          <div class="msg system">–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –£–¥–∞—á–∏!</div>
        </div>
        <div class="chat-input-row">
          <input type="text" id="chatInput" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." maxlength="100" onkeydown="if(event.key==='Enter')sendChat()">
          <button onclick="sendChat()">‚Üí</button>
        </div>
      </div>

      <button class="btn btn-small btn-danger" onclick="leaveGame()">–ü–æ–∫–∏–Ω—É—Ç—å –∏–≥—Ä—É</button>
    </div>
  </div>
</div>

<!-- WIN MODAL -->
<div class="modal-overlay" id="winModal">
  <div class="modal">
    <h2 id="winTitle">–ü–û–ë–ï–î–ê!</h2>
    <p id="winText">–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ —ç—Ç—É –ø–∞—Ä—Ç–∏—é!</p>
    <button class="btn" onclick="backToMenu()">–í –º–µ–Ω—é</button>
  </div>
</div>

<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

<script>
// ====================== AUDIO ======================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
let soundEnabled = true;

function initAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
}

function playSound(type) {
  if (!soundEnabled) return;
  initAudio();
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    switch(type) {
      case 'move':
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.start(); osc.stop(audioCtx.currentTime + 0.15);
        break;
      case 'capture':
        osc.frequency.setValueAtTime(600, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
        osc.start(); osc.stop(audioCtx.currentTime + 0.25);
        break;
      case 'king':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(500, audioCtx.currentTime);
        osc.frequency.setValueAtTime(700, audioCtx.currentTime + 0.1);
        osc.frequency.setValueAtTime(900, audioCtx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
        osc.start(); osc.stop(audioCtx.currentTime + 0.4);
        break;
      case 'win':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.setValueAtTime(500, audioCtx.currentTime + 0.15);
        osc.frequency.setValueAtTime(600, audioCtx.currentTime + 0.3);
        osc.frequency.setValueAtTime(800, audioCtx.currentTime + 0.45);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.7);
        osc.start(); osc.stop(audioCtx.currentTime + 0.7);
        break;
      case 'click':
        osc.frequency.setValueAtTime(800, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
        osc.start(); osc.stop(audioCtx.currentTime + 0.05);
        break;
    }
  } catch(e) {}
}

document.getElementById('soundBtn').addEventListener('click', () => {
  soundEnabled = !soundEnabled;
  document.getElementById('soundBtn').textContent = soundEnabled ? 'üîä' : 'üîá';
});

// ====================== PARTICLES ======================
(function createParticles() {
  const container = document.getElementById('particles');
  for (let i = 0; i < 40; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.style.left = Math.random() * 100 + '%';
    p.style.animationDuration = (8 + Math.random() * 15) + 's';
    p.style.animationDelay = (Math.random() * 10) + 's';
    p.style.width = p.style.height = (1 + Math.random() * 3) + 'px';
    container.appendChild(p);
  }
})();

// ====================== NAVIGATION ======================
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

function showMenu() {
  cleanupPeer();
  showScreen('menuScreen');
}

function showRules() { showScreen('rulesScreen'); }
function showJoinScreen() { showScreen('joinScreen'); }

// ====================== PEER CONNECTION ======================
let peer = null;
let conn = null;
let myColor = null; // 'white' or 'black'
let isHost = false;
let roomCode = '';
let gameActive = false;

// Signaling via PeerJS public server
// Room code maps to peer ID: "checkers-XXXXXX"

function generateCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function getPeerId(code) {
  return 'nochess-checkers-' + code.toUpperCase();
}

function cleanupPeer() {
  gameActive = false;
  if (conn) { try { conn.close(); } catch(e){} conn = null; }
  if (peer) { try { peer.destroy(); } catch(e){} peer = null; }
}

function createRoom() {
  playSound('click');
  cleanupPeer();
  roomCode = generateCode();
  const peerId = getPeerId(roomCode);
  isHost = true;
  myColor = 'white';

  showScreen('createScreen');
  document.getElementById('roomCodeDisplay').textContent = roomCode;
  const statusEl = document.getElementById('createStatus');
  statusEl.className = 'status waiting';
  statusEl.innerHTML = '<span class="spinner"></span> –û–∂–∏–¥–∞–Ω–∏–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...';

  peer = new Peer(peerId, {
    debug: 0,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' }
      ]
    }
  });

  peer.on('open', (id) => {
    console.log('Host peer opened:', id);
  });

  peer.on('connection', (connection) => {
    conn = connection;
    setupConnection();
    statusEl.className = 'status connected';
    statusEl.textContent = '‚úì –ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è!';
    setTimeout(() => {
      startGame();
      conn.send({ type: 'start', color: 'black' });
    }, 500);
  });

  peer.on('error', (err) => {
    console.error('Peer error:', err);
    if (err.type === 'unavailable-id') {
      statusEl.className = 'status error';
      statusEl.textContent = '‚úó –ö–æ–¥ –∑–∞–Ω—è—Ç, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞';
      setTimeout(() => { createRoom(); }, 1500);
    } else {
      statusEl.className = 'status error';
      statusEl.textContent = '‚úó –û—à–∏–±–∫–∞: ' + err.type;
    }
  });
}

function joinRoom() {
  playSound('click');
  const code = document.getElementById('joinCodeInput').value.trim().toUpperCase();
  if (code.length < 3) {
    showJoinStatus('–í–≤–µ–¥–∏ –∫–æ–¥ –∫–æ–º–Ω–∞—Ç—ã!', 'error');
    return;
  }

  cleanupPeer();
  roomCode = code;
  isHost = false;
  myColor = 'black';

  showJoinStatus('<span class="spinner"></span> –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...', 'waiting');

  peer = new Peer(undefined, {
    debug: 0,
    config: {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' }
      ]
    }
  });

  peer.on('open', () => {
    const peerId = getPeerId(code);
    conn = peer.connect(peerId, { reliable: true });
    setupConnection();

    conn.on('open', () => {
      showJoinStatus('‚úì –ü–æ–¥–∫–ª—é—á–µ–Ω–æ!', 'connected');
    });
  });

  peer.on('error', (err) => {
    console.error('Join error:', err);
    if (err.type === 'peer-unavailable') {
      showJoinStatus('‚úó –ö–æ–º–Ω–∞—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å –∫–æ–¥!', 'error');
    } else {
      showJoinStatus('‚úó –û—à–∏–±–∫–∞: ' + err.type, 'error');
    }
  });
}

function showJoinStatus(html, type) {
  const el = document.getElementById('joinStatus');
  el.style.display = 'block';
  el.className = 'status ' + type;
  el.innerHTML = html;
}

function setupConnection() {
  conn.on('data', (data) => {
    handleMessage(data);
  });

  conn.on('close', () => {
    if (gameActive) {
      addChatMsg('–°–∏—Å—Ç–µ–º–∞', '–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ –æ—Ç–∫–ª—é—á–∏–ª—Å—è.', true);
      gameActive = false;
    }
  });

  conn.on('error', (err) => {
    console.error('Connection error:', err);
  });
}

function sendData(data) {
  if (conn && conn.open) {
    conn.send(data);
  }
}

function handleMessage(data) {
  switch (data.type) {
    case 'start':
      myColor = data.color;
      startGame();
      break;
    case 'move':
      applyRemoteMove(data);
      break;
    case 'chat':
      addChatMsg('–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫', data.text, false);
      break;
    case 'resign':
      gameActive = false;
      showWinModal(myColor === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ', '–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫ —Å–¥–∞–ª—Å—è!');
      break;
  }
}

function cancelRoom() {
  playSound('click');
  cleanupPeer();
  showMenu();
}

function copyRoomCode() {
  const code = document.getElementById('roomCodeDisplay').textContent;
  navigator.clipboard.writeText(code).then(() => {
    const toast = document.getElementById('copyToast');
    toast.classList.add('show');
    setTimeout(() => toast.classList.remove('show'), 2000);
  }).catch(() => {});
}

// ====================== CHECKERS GAME ======================
let board = [];
let selectedPiece = null;
let currentTurn = 'white'; // white goes first
let validMoves = [];
let capturedWhite = 0;
let capturedBlack = 0;
let multiCapturePiece = null; // for chain captures

// Board: 0 = empty, 1 = white, 2 = black, 3 = white king, 4 = black king

function initBoard() {
  board = [];
  for (let r = 0; r < 8; r++) {
    board[r] = [];
    for (let c = 0; c < 8; c++) {
      board[r][c] = 0;
      if ((r + c) % 2 === 1) {
        if (r < 3) board[r][c] = 2; // black top
        if (r > 4) board[r][c] = 1; // white bottom
      }
    }
  }
  currentTurn = 'white';
  selectedPiece = null;
  validMoves = [];
  capturedWhite = 0;
  capturedBlack = 0;
  multiCapturePiece = null;
}

function startGame() {
  gameActive = true;
  initBoard();
  showScreen('gameScreen');
  renderBoard();
  updateUI();
  document.getElementById('chatMessages').innerHTML = '<div class="msg system">–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å! –¢—ã –∏–≥—Ä–∞–µ—à—å –∑–∞ ' + (myColor === 'white' ? '–±–µ–ª—ã—Ö ‚¨ú' : '—á—ë—Ä–Ω—ã—Ö ‚¨õ') + '</div>';
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
      cell.dataset.row = r;
      cell.dataset.col = c;

      if (selectedPiece && selectedPiece.row === r && selectedPiece.col === c) {
        cell.classList.add('selected');
      }

      // Highlight valid move cells
      const moveTarget = validMoves.find(m => m.toRow === r && m.toCol === c);
      if (moveTarget) {
        cell.classList.add('highlight');
      }

      const piece = board[r][c];
      if (piece > 0) {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'piece';
        if (piece === 1 || piece === 3) pieceEl.classList.add('white-piece');
        if (piece === 2 || piece === 4) pieceEl.classList.add('black-piece');
        if (piece === 3 || piece === 4) pieceEl.classList.add('king');
        cell.appendChild(pieceEl);
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      boardEl.appendChild(cell);
    }
  }
}

function updateUI() {
  const p1 = document.getElementById('player1Info');
  const p2 = document.getElementById('player2Info');

  p1.innerHTML = '<span class="color-dot white"></span> –ë–µ–ª—ã–µ' + (myColor === 'white' ? ' (–í—ã)' : '');
  p2.innerHTML = '<span class="color-dot black"></span> –ß—ë—Ä–Ω—ã–µ' + (myColor === 'black' ? ' (–í—ã)' : '');

  p1.classList.toggle('active-player', currentTurn === 'white');
  p2.classList.toggle('active-player', currentTurn === 'black');

  const turnEl = document.getElementById('turnIndicator');
  if (currentTurn === myColor) {
    turnEl.textContent = 'üî• –í–∞—à —Ö–æ–¥!';
    turnEl.style.color = '#ff4500';
  } else {
    turnEl.textContent = '‚è≥ –•–æ–¥ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...';
    turnEl.style.color = '#888';
  }

  // Captured display
  const capWhiteEl = document.getElementById('capturedWhite');
  const capBlackEl = document.getElementById('capturedBlack');
  capWhiteEl.innerHTML = '';
  capBlackEl.innerHTML = '';
  for (let i = 0; i < capturedWhite; i++) {
    capWhiteEl.innerHTML += '<div class="captured-piece white-piece"></div>';
  }
  for (let i = 0; i < capturedBlack; i++) {
    capBlackEl.innerHTML += '<div class="captured-piece black-piece"></div>';
  }
}

function isMyPiece(piece) {
  if (myColor === 'white') return piece === 1 || piece === 3;
  if (myColor === 'black') return piece === 2 || piece === 4;
  return false;
}

function isOpponentPiece(piece, color) {
  if (color === 'white') return piece === 2 || piece === 4;
  if (color === 'black') return piece === 1 || piece === 3;
  return false;
}

function isSameColor(piece, color) {
  if (color === 'white') return piece === 1 || piece === 3;
  if (color === 'black') return piece === 2 || piece === 4;
  return false;
}

function isKing(piece) {
  return piece === 3 || piece === 4;
}

function getColor(piece) {
  if (piece === 1 || piece === 3) return 'white';
  if (piece === 2 || piece === 4) return 'black';
  return null;
}

// Get all valid moves for a piece at (r,c)
function getMovesForPiece(r, c, boardState) {
  const piece = boardState[r][c];
  if (piece === 0) return { moves: [], captures: [] };

  const color = getColor(piece);
  const king = isKing(piece);
  const moves = [];
  const captures = [];

  // Directions
  let dirs;
  if (king) {
    dirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
  } else if (color === 'white') {
    dirs = [[-1, -1], [-1, 1]]; // white moves up
  } else {
    dirs = [[1, -1], [1, 1]]; // black moves down
  }

  for (const [dr, dc] of dirs) {
    const nr = r + dr;
    const nc = c + dc;
    if (nr < 0 || nr > 7 || nc < 0 || nc > 7) continue;

    if (boardState[nr][nc] === 0) {
      moves.push({ fromRow: r, fromCol: c, toRow: nr, toCol: nc, captures: [] });
    } else if (isOpponentPiece(boardState[nr][nc], color)) {
      // Can we jump?
      const jr = nr + dr;
      const jc = nc + dc;
      if (jr >= 0 && jr <= 7 && jc >= 0 && jc <= 7 && boardState[jr][jc] === 0) {
        captures.push({ fromRow: r, fromCol: c, toRow: jr, toCol: jc, captures: [{ row: nr, col: nc }] });
      }
    }
  }

  // For kings, also check capture directions that are not in normal move dirs
  if (!king) {
    // Non-king can capture backwards too in some rule sets
    // Standard international: can capture backwards. Let's allow it.
    const capDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
    for (const [dr, dc] of capDirs) {
      // Skip dirs we already checked
      if (dirs.some(d => d[0] === dr && d[1] === dc)) continue;

      const nr = r + dr;
      const nc = c + dc;
      if (nr < 0 || nr > 7 || nc < 0 || nc > 7) continue;

      if (isOpponentPiece(boardState[nr][nc], color)) {
        const jr = nr + dr;
        const jc = nc + dc;
        if (jr >= 0 && jr <= 7 && jc >= 0 && jc <= 7 && boardState[jr][jc] === 0) {
          captures.push({ fromRow: r, fromCol: c, toRow: jr, toCol: jc, captures: [{ row: nr, col: nc }] });
        }
      }
    }
  }

  return { moves, captures };
}

// Get all possible chain captures from a position
function getChainCaptures(r, c, boardState, alreadyCaptured = []) {
  const piece = boardState[r][c];
  const color = getColor(piece);
  const king = isKing(piece);
  const results = [];

  const capDirs = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

  for (const [dr, dc] of capDirs) {
    const nr = r + dr;
    const nc = c + dc;
    if (nr < 0 || nr > 7 || nc < 0 || nc > 7) continue;

    // Check if this piece was already captured in this chain
    if (alreadyCaptured.some(cp => cp.row === nr && cp.col === nc)) continue;

    if (isOpponentPiece(boardState[nr][nc], color)) {
      const jr = nr + dr;
      const jc = nc + dc;
      if (jr >= 0 && jr <= 7 && jc >= 0 && jc <= 7 && boardState[jr][jc] === 0) {
        const captured = { row: nr, col: nc };
        const newCaptured = [...alreadyCaptured, captured];

        // Temporarily make the move
        const tempBoard = boardState.map(row => [...row]);
        tempBoard[jr][jc] = tempBoard[r][c];
        tempBoard[r][c] = 0;
        tempBoard[nr][nc] = 0;

        // Check for promotion
        if (!king) {
          if (color === 'white' && jr === 0) tempBoard[jr][jc] = 3;
          if (color === 'black' && jr === 7) tempBoard[jr][jc] = 4;
        }

        // Continue chain
        const further = getChainCaptures(jr, jc, tempBoard, newCaptured);

        if (further.length === 0) {
          results.push({
            fromRow: r, fromCol: c, toRow: jr, toCol: jc,
            captures: newCaptured
          });
        } else {
          for (const f of further) {
            results.push({
              fromRow: r, fromCol: c, toRow: f.toRow, toCol: f.toCol,
              captures: [...newCaptured, ...f.captures.filter(fc => !newCaptured.some(nc2 => nc2.row === fc.row && nc2.col === fc.col))],
              chain: [{ toRow: jr, toCol: jc }, ...(f.chain || [{ toRow: f.toRow, toCol: f.toCol }])]
            });
          }
        }
      }
    }
  }

  return results;
}

// Get all valid moves for current player, enforcing mandatory capture
function getAllMoves(color, boardState) {
  let allMoves = [];
  let allCaptures = [];

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (isSameColor(boardState[r][c], color)) {
        const { moves, captures } = getMovesForPiece(r, c, boardState);
        allMoves.push(...moves);

        // Get chain captures
        const chains = getChainCaptures(r, c, boardState);
        if (chains.length > 0) {
          allCaptures.push(...chains);
        } else {
          allCaptures.push(...captures);
        }
      }
    }
  }

  // If captures exist, must capture (and prefer longest chain)
  if (allCaptures.length > 0) {
    const maxLen = Math.max(...allCaptures.map(c => c.captures.length));
    return allCaptures.filter(c => c.captures.length === maxLen);
  }

  return allMoves;
}

function onCellClick(r, c) {
  if (!gameActive) return;
  if (currentTurn !== myColor) return;

  playSound('click');

  const piece = board[r][c];

  // If we have a multi-capture in progress, only allow continuing
  if (multiCapturePiece) {
    const move = validMoves.find(m => m.toRow === r && m.toCol === c);
    if (move) {
      executeMove(move);
    }
    return;
  }

  // Clicking on own piece: select it
  if (isSameColor(piece, myColor)) {
    const allMoves = getAllMoves(myColor, board);
    // Filter moves for this piece
    const pieceMoves = allMoves.filter(m => m.fromRow === r && m.fromCol === c);

    if (pieceMoves.length > 0) {
      selectedPiece = { row: r, col: c };
      validMoves = pieceMoves;
    } else {
      // Check if there are forced captures from other pieces
      if (allMoves.length > 0 && allMoves[0].captures && allMoves[0].captures.length > 0) {
        addChatMsg('–°–∏—Å—Ç–µ–º–∞', '–í—ã –¥–æ–ª–∂–Ω—ã –±–∏—Ç—å!', true);
      }
      selectedPiece = null;
      validMoves = [];
    }
    renderBoard();
    return;
  }

  // Clicking on a valid move target
  if (selectedPiece) {
    const move = validMoves.find(m => m.toRow === r && m.toCol === c);
    if (move) {
      executeMove(move);
      return;
    }
  }

  selectedPiece = null;
  validMoves = [];
  renderBoard();
}

function executeMove(move) {
  const piece = board[move.fromRow][move.fromCol];
  board[move.toRow][move.toCol] = piece;
  board[move.fromRow][move.fromCol] = 0;

  let captured = false;
  let captureCount = 0;

  // Remove first captured piece (for step-by-step chain)
  if (move.captures && move.captures.length > 0) {
    // For simple moves, remove the captured piece
    // For chain captures we need to handle step by step
    const capTarget = move.captures[0];
    const capPiece = board[capTarget.row][capTarget.col];
    if (capPiece > 0) {
      if (getColor(capPiece) === 'white') capturedWhite++;
      else capturedBlack++;
      board[capTarget.row][capTarget.col] = 0;
      captured = true;
      captureCount++;
    }
  }

  // Check promotion
  let promoted = false;
  const color = getColor(board[move.toRow][move.toCol]);
  if (color === 'white' && move.toRow === 0 && !isKing(board[move.toRow][move.toCol])) {
    board[move.toRow][move.toCol] = 3;
    promoted = true;
  }
  if (color === 'black' && move.toRow === 7 && !isKing(board[move.toRow][move.toCol])) {
    board[move.toRow][move.toCol] = 4;
    promoted = true;
  }

  // Play sound
  if (captured) playSound('capture');
  else playSound('move');
  if (promoted) setTimeout(() => playSound('king'), 200);

  // Check for more captures from the new position (chain)
  if (captured && !promoted) {
    const furtherCaptures = getChainCaptures(move.toRow, move.toCol, board);
    if (furtherCaptures.length > 0) {
      // Must continue capturing
      multiCapturePiece = { row: move.toRow, col: move.toCol };
      selectedPiece = multiCapturePiece;
      validMoves = furtherCaptures;

      // Send intermediate move
      sendData({
        type: 'move',
        board: JSON.parse(JSON.stringify(board)),
        turn: currentTurn,
        capturedWhite,
        capturedBlack,
        continuing: true
      });

      renderBoard();
      updateUI();
      return;
    }
  }

  // Turn complete
  multiCapturePiece = null;
  selectedPiece = null;
  validMoves = [];
  const prevTurn = currentTurn;
  currentTurn = currentTurn === 'white' ? 'black' : 'white';

  // Send move to opponent
  sendData({
    type: 'move',
    board: JSON.parse(JSON.stringify(board)),
    turn: currentTurn,
    capturedWhite,
    capturedBlack,
    continuing: false
  });

  renderBoard();
  updateUI();
  checkWin();
}

function applyRemoteMove(data) {
  board = data.board;
  currentTurn = data.turn;
  capturedWhite = data.capturedWhite;
  capturedBlack = data.capturedBlack;

  if (!data.continuing) {
    selectedPiece = null;
    validMoves = [];
    multiCapturePiece = null;

    // Check if it captures
    playSound('move');
  } else {
    playSound('capture');
  }

  renderBoard();
  updateUI();

  if (!data.continuing) {
    checkWin();
  }
}

function checkWin() {
  // Count pieces
  let whitePieces = 0, blackPieces = 0;
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (board[r][c] === 1 || board[r][c] === 3) whitePieces++;
      if (board[r][c] === 2 || board[r][c] === 4) blackPieces++;
    }
  }

  if (whitePieces === 0) {
    gameActive = false;
    playSound('win');
    showWinModal('–ß—ë—Ä–Ω—ã–µ', '–£ –±–µ–ª—ã—Ö –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å —à–∞—à–µ–∫!');
    return;
  }
  if (blackPieces === 0) {
    gameActive = false;
    playSound('win');
    showWinModal('–ë–µ–ª—ã–µ', '–£ —á—ë—Ä–Ω—ã—Ö –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å —à–∞—à–µ–∫!');
    return;
  }

  // Check if current player has moves
  const moves = getAllMoves(currentTurn, board);
  if (moves.length === 0) {
    gameActive = false;
    playSound('win');
    const winner = currentTurn === 'white' ? '–ß—ë—Ä–Ω—ã–µ' : '–ë–µ–ª—ã–µ';
    showWinModal(winner, (currentTurn === 'white' ? '–ë–µ–ª—ã–µ' : '–ß—ë—Ä–Ω—ã–µ') + ' –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã!');
  }
}

function showWinModal(winner, reason) {
  const modal = document.getElementById('winModal');
  const title = document.getElementById('winTitle');
  const text = document.getElementById('winText');

  const iWon = (winner === '–ë–µ–ª—ã–µ' && myColor === 'white') || (winner === '–ß—ë—Ä–Ω—ã–µ' && myColor === 'black');

  title.textContent = iWon ? 'üèÜ –ü–û–ë–ï–î–ê!' : 'üíÄ –ü–û–†–ê–ñ–ï–ù–ò–ï';
  text.textContent = reason + ' ' + winner + ' –ø–æ–±–µ–∂–¥–∞—é—Ç!';
  modal.classList.add('active');
}

function backToMenu() {
  document.getElementById('winModal').classList.remove('active');
  cleanupPeer();
  showMenu();
}

function leaveGame() {
  playSound('click');
  if (gameActive && conn && conn.open) {
    sendData({ type: 'resign' });
  }
  gameActive = false;
  cleanupPeer();
  showMenu();
}

// ====================== CHAT ======================
function sendChat() {
  const input = document.getElementById('chatInput');
  const text = input.value.trim();
  if (!text) return;

  addChatMsg('–í—ã', text, false);
  sendData({ type: 'chat', text });
  input.value = '';
}

function addChatMsg(sender, text, isSystem) {
  const container = document.getElementById('chatMessages');
  const msg = document.createElement('div');
  msg.className = 'msg' + (isSystem ? ' system' : '');
  if (isSystem) {
    msg.textContent = text;
  } else {
    msg.innerHTML = '<span class="sender">' + sender + ':</span> ' + escapeHtml(text);
  }
  container.appendChild(msg);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ====================== INIT ======================
document.getElementById('joinCodeInput').addEventListener('input', function() {
  this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
});
</script>

</body>
</html>